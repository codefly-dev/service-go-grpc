package adapters

import (
	"context"
	"fmt"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	gen "github.com/hygge-io/go-grpc/base/adapters/v1"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"net/http"
	"strings"
)

type RestServer struct {
	config *Configuration
}

func NewRestServer(c *Configuration) (*RestServer, error) {
	server := &RestServer{config: c}
	// Start Rest server (and proxy calls to gRPC server endpoint)
	return server, nil
}

func (s *RestServer) Run(ctx context.Context) error {
	fmt.Println("Starting Rest server at", s.config.EndpointHttp)
	gwMux := runtime.NewServeMux()

	opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}
	err := gen.RegisterWebHandlerFromEndpoint(ctx, gwMux, s.config.EndpointGrpc, opts)
	if err != nil {
		return err
	}
	var handler http.Handler = gwMux

	// Serve static files
	if s.config.Static != "" {
		fs := http.FileServer(http.Dir(s.config.Static))

		// Custom handler
		handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// If path is root or starts with a known static file prefix, serve static files
			if r.URL.Path == "/" || strings.HasSuffix(r.URL.Path, ".css") || strings.HasSuffix(r.URL.Path, ".js") {
				fs.ServeHTTP(w, r)
				return
			}
			// Otherwise, forward the request to the gRPC-Gateway
			gwMux.ServeHTTP(w, r)
		})
	}

	return http.ListenAndServe(s.config.EndpointHttp, handler)
}
